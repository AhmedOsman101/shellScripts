#!/usr/bin/env bash
#
# --- SCRIPT SIGNATURE --- #
#
#                                      ▄▄               ██
#                                      ██    ██         ▀▀
#   ██▄████   ▄████▄    ▄█████▄   ▄███▄██  ███████    ████     ████▄██▄   ▄████▄
#   ██▀      ██▄▄▄▄██   ▀ ▄▄▄██  ██▀  ▀██    ██         ██     ██ ██ ██  ██▄▄▄▄██
#   ██       ██▀▀▀▀▀▀  ▄██▀▀▀██  ██    ██    ██         ██     ██ ██ ██  ██▀▀▀▀▀▀
#   ██       ▀██▄▄▄▄█  ██▄▄▄███  ▀██▄▄███    ██▄▄▄   ▄▄▄██▄▄▄  ██ ██ ██  ▀██▄▄▄▄█
#   ▀▀         ▀▀▀▀▀    ▀▀▀▀ ▀▀    ▀▀▀ ▀▀     ▀▀▀▀   ▀▀▀▀▀▀▀▀  ▀▀ ▀▀ ▀▀    ▀▀▀▀▀
#
#
# --- DESCRIPTION --- #
# Accepts file(s) or raw text and outputs how long it takes to read in minutes.
# --- DEPENDENCIES --- #
# - pandoc
# - wc
# --- END SIGNATURE --- #

set -eo pipefail
trap 'exit 1' SIGUSR1

eval "$(include "lib/cmdarg.sh")"
eval "$(include "lib/helpers.sh")"
eval "$(include "check-deps")"
checkDeps "$0"

# --- cmdarg setup --- #
cmdarg_info "header" "$(get-desc "$0")"
cmdarg 'q' 'quiet' "Quiet output, prints only minutes to read"
cmdarg 'w?' 'wpm' "Words per minute" '200'
cmdarg_parse "$@"
# ---  Main script logic --- #
quiet="${cmdarg_cfg[quiet]}"
WPM="${cmdarg_cfg[wpm]}"

hasStdinRedirected() {
  local stdin_source
  stdin_source=$(readlink /proc/self/fd/0 2>/dev/null || echo "")
  [[ "${stdin_source}" != "/dev/null" ]]
}

countWordsFromStdin() {
  pandoc -t plain 2>/dev/null | wc -w | trim
}

countWordsFromFile() {
  local file="$1"
  pandoc "${file}" -t plain 2>/dev/null | wc -w | trim
}

calculateMinutes() {
  local words="$1"
  local minutes=$(((words + WPM - 1) / WPM))
  ((minutes < 1)) && minutes=1
  echo "${minutes}"
}

outputResult() {
  local minutes="$1"
  local label="$2"

  if [[ "${quiet}" != true ]]; then
    if [[ -n "${label}" ]]; then
      printf '%s min read %s\n' "${minutes}" "${label}"
    else
      printf '%s min read\n' "${minutes}"
    fi
  else
    printf '%sm\n' "${minutes}"
  fi
}

outputTotal() {
  if [[ "${quiet}" != true ]]; then
    printf '%s min read TOTAL\n' "${total}"
  else
    printf '%sm TOTAL\n' "${total}"
  fi
}

processFile() {
  local file="$1"

  if [[ ! -r "${file}" ]]; then
    log-warning "Cannot read: ${file}"
    failed=$((failed + 1))
    return 1
  fi

  local words
  words=$(countWordsFromFile "${file}")

  if [[ -z "${words}" || "${words}" -eq 0 ]]; then
    log-warning "No readable content: ${file}"
    processed=$((processed + 1))
    return 0
  fi

  local minutes
  minutes=$(calculateMinutes "${words}")

  total=$((total + minutes))
  processed=$((processed + 1))

  outputResult "${minutes}" "${file}"
}

processStdin() {
  local words
  words=$(countWordsFromStdin <&0)

  if [[ -z "${words}" || "${words}" -eq 0 ]]; then
    log-warning "No readable content"
    processed=$((processed + 1))
    return 0
  fi

  local minutes
  minutes=$(calculateMinutes "${words}")

  total=$((total + minutes))
  processed=$((processed + 1))

  outputResult "${minutes}" ""
}

processStdinFromPeek() {
  local data
  local words

  if data=$(hasStdinWithData); then
    words=$(printf '%s\n' "${data}" | countWordsFromStdin)

    if [[ -z "${words}" || "${words}" -eq 0 ]]; then
      log-warning "No readable content"
      processed=$((processed + 1))
      return 0
    fi

    local minutes
    minutes=$(calculateMinutes "${words}")

    total=$((total + minutes))
    processed=$((processed + 1))

    outputResult "${minutes}" ""
    return 0
  fi

  return 1
}

processMultipleInputs() {
  for file in "${argv[@]}"; do
    if [[ ! -r "${file}" ]]; then
      log-warning "Cannot read: ${file}"
      failed=$((failed + 1))
      continue
    fi

    local words
    words=$(countWordsFromFile "${file}")

    if [[ -z "${words}" || "${words}" -eq 0 ]]; then
      log-warning "No readable content: ${file}"
      continue
    fi

    local minutes
    minutes=$(calculateMinutes "${words}")

    total=$((total + minutes))
    processed=$((processed + 1))

    outputResult "${minutes}" "${file}"
  done
}

main() {
  local total=0
  local processed=0
  local failed=0

  if ((argc == 0)); then
    if ! [[ -t 0 ]]; then
      processStdin
    else
      terminate "No files provided and stdin is not available"
    fi
  else
    if ! [[ -t 0 ]]; then
      processStdin
    else
      if ((argc == 1)); then
        processFile "${argv[0]}"
      else
        processMultipleInputs
      fi
    fi
  fi

  if ((processed > 1)); then
    outputTotal
  fi

  if ((failed > 0)); then
    exit 1
  fi
}

main "$@"
