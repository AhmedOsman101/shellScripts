#!/usr/bin/env bash

# shellcheck disable=SC2310
# disable hinting that invoking functions inside an if statement disables -e flag

set -eo pipefail

trap 'exit 1' SIGUSR1

is-git-repo

if [[ -z ${COMMIT_SAGE_CONFIG_PATH} ]]; then
  configFile="$(dirname $0)/config.yml"
  # log-debug "no config found"
  # log-debug "using default config: '${configFile}'"
else
  configFile="${COMMIT_SAGE_CONFIG_PATH}"
fi

onlyStaged=$(yq -r ".onlyStaged" ${configFile})

cd "$(git-root)" || log-error "unable to change directory to the git repo root directory"

hasChanges() {
  local type
  type=${1:-unstaged}

  case "${type}" in
  staged)
    output=$(git diff --cached --name-only)
    ;;
  untracked)
    output=$(git ls-files --others --exclude-standard)
    ;;
  deleted)
    output=$(git ls-files --deleted)
    ;;
  unstaged)
    output=$(git diff --name-only)
    ;;
  ? | *)
    log-error "Invalid change type: ${type}"
    ;;
  esac
  # output.length > 0
  output=$(trim "${output}")

  # True (0) if output is non-empty
  [[ ${#output} -gt 0 ]] && return 0 || return 1
}

hasHead() {
  git rev-parse HEAD >/dev/null 2>&1 && return 0 || return 1
}

# Simple hash function mimicking TypeScript's calculateFileHash
calculateFileHash() {
  local content="$1"
  # Convert content to base64 and take first 7 characters
  echo -n "${content}" | base64 | head -c 7
}

isSubModule() {
  if git ls-files --stage -- $1 | rg -q "160000"; then
    return 0
  else
    return 1
  fi
}

processStagedOnly() {
  local output stagedFiles=()
  # Get staged files
  output=$(git diff --cached --name-only)

  # Check if git command succeeded
  [[ $? -ne 0 ]] && log-error "Error: Git command failed"

  mapfile -t lines <<<"${output}"
  for line in "${lines[@]}"; do
    trimmed=$(trim "${line}")
    if [[ -n "${trimmed}" ]]; then
      stagedFiles+=("${trimmed}")
    fi
  done

  for file in "${stagedFiles[@]}"; do
    if ! isSubModule "file"; then
      local fileDiff=$(git diff --cached -- ${file})
      trimmed=$(trim "${fileDiff}")
      if [[ -n "${trimmed}" ]]; then
        diffs+=("${trimmed}")
      fi
    fi
  done
}

processStaged() {
  local output stagedFiles=()
  # Get staged files
  output=$(git diff --cached --name-only)

  # Check if git command succeeded
  [[ $? -ne 0 ]] && log-error "Error: Git command failed"

  mapfile -t lines <<<"${output}"
  for line in "${lines[@]}"; do
    trimmed=$(trim "${line}")
    if [[ -n "${trimmed}" ]]; then
      stagedFiles+=("${trimmed}")
    fi
  done

  # Generate diff for each staged file
  for file in "${stagedFiles[@]}"; do
    if ! isSubModule "file"; then
      local fileDiff=$(git diff --cached -- ${file})
      trimmed=$(trim "${fileDiff}")
      if [[ -n "${trimmed}" ]]; then
        diffs+=($'# Staged changes:\n'"${trimmed}")
      fi
    fi
  done
}

processUnstaged() {
  local output unstagedFiles=() unstagedDiffs=()
  # Get staged files
  output=$(git diff --name-only)

  # Check if git command succeeded
  [[ $? -ne 0 ]] && log-error "Error: Git command failed"

  mapfile -t lines <<<"${output}"
  for line in "${lines[@]}"; do
    trimmed=$(trim "${line}")
    if [[ -n "${trimmed}" ]]; then
      unstagedFiles+=("${trimmed}")
    fi
  done

  # Generate diff for each unstaged file
  for file in "${unstagedFiles[@]}"; do
    if ! isSubModule "file"; then
      local fileDiff=$(git diff -- ${file})
      trimmed=$(trim "${fileDiff}")
      if [[ -n "${trimmed}" ]]; then
        diffs+=($'# Unstaged changes:\n'"${trimmed}")
      fi
    fi
  done

}

processUntracked() {
  local output untrackedFiles=() untrackedDiff=()

  # Get untracked files
  output=$(git ls-files --others --exclude-standard)
  [[ $? -ne 0 ]] && log-error "Error: Git command failed"

  # Split output into array and filter non-empty lines
  mapfile -t lines <<<"${output}"
  for line in "${lines[@]}"; do
    trimmed=$(trim "${line}")
    if [[ -n "${trimmed}" ]]; then
      untrackedFiles+=("${trimmed}")
    fi
  done

  # Generate diff for each untracked file
  for file in "${untrackedFiles[@]}"; do
    local diffContent=""
    if content=$(cat "${file}" 2>/dev/null); then
      # Read file content succeeded
      mapfile -t contentLines <<<"${content}"
      local contentDiff=()
      for line in "${contentLines[@]}"; do
        contentDiff+=("+${line}")
      done
      # Join contentDiff with newlines
      contentDiffText=$(printf '%s\n' "${contentDiff[@]}")
      local hash=$(calculateFileHash "${content}")
      local lineCount=${#contentLines[@]}
      diffContent=$(echo -e "diff --git a/${file} b/${file}\nnew file mode 100644\nindex 0000000..${hash}\n--- /dev/null\n+++ b/${file}\n@@ -0,0 +1,${lineCount} @@\n${contentDiffText}")
    else
      diffContent=""
      log-error "Error reading new file ${file}"
    fi
    # Add to untrackedDiff array
    untrackedDiff+=("${diffContent}")
  done

  # Filter valid diffs and add to diffs array if non-empty
  local validUntrackedDiffs=()
  for diff in "${untrackedDiff[@]}"; do
    trimmed=$(trim "${diff}")
    if [[ -n "${trimmed}" ]]; then
      validUntrackedDiffs+=("${trimmed}")
    fi
  done

  if [[ ${#validUntrackedDiffs[@]} -gt 0 ]]; then
    diffs+=($'# New files:\n'"$(printf '%s\n' "${validUntrackedDiffs[@]}")")
  fi
}

processDeleted() {
  local output deletedFiles=() deletedDiff=()

  # Get deleted files
  output=$(git ls-files --deleted)
  [[ $? -ne 0 ]] && log-error "Error: Git command failed"

  # Split output into array and filter non-empty lines
  mapfile -t lines <<<"${output}"
  for line in "${lines[@]}"; do
    trimmed=$(trim "${line}")
    if [[ -n "${trimmed}" ]]; then
      deletedFiles+=("${trimmed}")
    fi
  done

  # Generate diff for each deleted file
  for file in "${deletedFiles[@]}"; do
    local diffContent=""
    if oldContent=$(git show HEAD:${file}); then
      diffContent=$(echo -e "diff --git a/${file} b/${file}\ndeleted file mode 100644\n--- a/${file}\n+++ /dev/null\n@@ -1 +0,0 @@\n-$(trim ${oldContent})\n")
    else
      diffContent=""
      log-error "Error reading new file ${file}"
    fi

    # Add to untrackedDiff array
    deletedDiff+=("${diffContent}")
  done

  # Filter valid diffs and add to diffs array if non-empty
  local validDeletedDiffs=()
  for diff in "${deletedDiff[@]}"; do
    trimmed=$(trim "${diff}")
    if [[ -n "${trimmed}" ]]; then
      validDeletedDiffs+=("${trimmed}")
    fi
  done

  if [[ ${#validDeletedDiffs[@]} -gt 0 ]]; then
    local temp=$'# Deleted files:\n'"$(printf '%s\n' "${validDeletedDiffs[@]}")"
    # log-debug "${temp}"
    diffs+=("${temp}") # Append as a single element
  fi

}

getDiff() {
  local HasHead
  log-debug "${onlyStaged}"
  hasHead
  # 0 => True, 1 => False (e.g. empty repo)
  HasHead=$?

  # 0 => True, 1 => False
  hasChanges "staged" && hasStagedChanges=0 || hasStagedChanges=1

  # Only check unstaged if !onlyStaged
  if [[ "${onlyStaged}" != "true" ]] && hasChanges "unstaged"; then
    hasUnstagedChanges=0 # True
  # if no staged changes but there is changes in general
  elif [[ ${hasStagedChanges} -eq 1 ]] && hasChanges "unstaged"; then
    hasUnstagedChanges=0 # True
  else
    hasUnstagedChanges=1 # False
  fi

  # Only check untracked if !onlyStaged && !hasStagedChanges
  if [[ "${onlyStaged}" != "true" ]] &&
    [[ "${hasStagedChanges}" -eq 1 ]] &&
    hasChanges "untracked"; then
    hasUntrackedFiles=0 # True
  elif [[ ${hasStagedChanges} -eq 1 ]] && hasChanges "untracked"; then
    hasUntrackedFiles=0 # True
  else
    hasUntrackedFiles=1 # False
  fi

  # Only check deleted if hasHead && !onlyStaged && !hasStagedChanges
  if [[ "${HasHead}" -eq 0 ]] &&
    [[ "${onlyStaged}" != "true" ]] &&
    [[ "${hasStagedChanges}" -eq 1 ]] &&
    hasChanges "deleted"; then

    hasDeletedFiles=0 # True
  elif [[ "${HasHead}" -eq 0 ]] &&
    [[ ${hasStagedChanges} -eq 1 ]] &&
    hasChanges "deleted"; then
    hasDeletedFiles=0 # True
  else
    hasDeletedFiles=1 # False
  fi

  # Log results for debugging
  log-debug "hasHead: ${HasHead}"
  log-debug "hasStagedChanges: ${hasStagedChanges}"
  log-debug "hasUnstagedChanges: ${hasUnstagedChanges}"
  log-debug "hasUntrackedFiles: ${hasUntrackedFiles}"
  log-debug "hasDeletedFiles: ${hasDeletedFiles}"

  # Check if no changes exist (all are false, i.e., 1)
  if [[ "${hasStagedChanges}" -eq 1 ]] &&
    [[ "${hasUnstagedChanges}" -eq 1 ]] &&
    [[ "${hasUntrackedFiles}" -eq 1 ]] &&
    [[ "${hasDeletedFiles}" -eq 1 ]]; then
    log-error "No Changes Found"
  fi

  # ---- Diffs ---- #
  # ---- If we only want staged changes and there are some, return only those ---- #
  if [[ "${onlyStaged}" == "true" ]] && [[ "${hasStagedChanges}" -eq 0 ]]; then
    processStagedOnly
  else
    # ---- Otherwise, get all changes ---- #
    if [[ "${hasStagedChanges}" -eq 0 ]]; then
      processStaged
    fi

    if [[ "${hasUnstagedChanges}" -eq 0 ]]; then
      processUnstaged
    fi

    if [[ "${hasUntrackedFiles}" -eq 0 ]]; then
      processUntracked
    fi

    if [[ "${hasDeletedFiles}" -eq 0 ]]; then
      processDeleted
    fi

  fi

  combinedDiff=$(printf "%s\n\n" "${diffs[@]}" | trim)
  [[ -z "${combinedDiff}" ]] && log-error "No Changes Found"
  echo -e "${combinedDiff}"
}

