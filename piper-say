#!/usr/bin/env bash
#
# --- SCRIPT SIGNATURE --- #
#
#               ██
#               ▀▀
#  ██▄███▄    ████     ██▄███▄    ▄████▄    ██▄████            ▄▄█████▄   ▄█████▄  ▀██  ███
#  ██▀  ▀██     ██     ██▀  ▀██  ██▄▄▄▄██   ██▀                ██▄▄▄▄ ▀   ▀ ▄▄▄██   ██▄ ██
#  ██    ██     ██     ██    ██  ██▀▀▀▀▀▀   ██        █████     ▀▀▀▀██▄  ▄██▀▀▀██    ████▀
#  ███▄▄██▀  ▄▄▄██▄▄▄  ███▄▄██▀  ▀██▄▄▄▄█   ██                 █▄▄▄▄▄██  ██▄▄▄███     ███
#  ██ ▀▀▀    ▀▀▀▀▀▀▀▀  ██ ▀▀▀      ▀▀▀▀▀    ▀▀                  ▀▀▀▀▀▀    ▀▀▀▀ ▀▀     ██
#  ██                  ██                                                           ███
#
# --- DESCRIPTION --- #
# Text-to-speech script using Piper TTS and mpv
# Supports Pandoc input, Markdown, Word, PDF, HTML, URLs, and raw text
# Can pipe audio live or save to WAV
# --- DEPENDENCIES --- #
# - piper-tts | piper-tts (piper-tts-git)
# - mpv | aplay
# --- END SIGNATURE --- #

set -eo pipefail
trap 'exit 1' SIGUSR1

eval "$(include "lib/cmdarg.sh")"
eval "$(include "lib/helpers.sh")"
eval "$(include "check-deps")"
checkDeps "$0"

# --- cmdarg setup --- #
cmdarg_info "header" "$(get-desc "$0")"
cmdarg "l" "list" "Lists available voices"
cmdarg "v?" "voice" "The voice to use" ""
cmdarg "o?" "output" "Optional output WAV file path" ""
cmdarg_parse "$@"
# ---  Main script logic --- #
list="${cmdarg_cfg['list']}"
voice="${cmdarg_cfg['voice']}"
out_file="${cmdarg_cfg['output']}"

PIPER_VOICES_DIR="${XDG_DATA_HOME:-${HOME}/.local/share}/piper"
PIPER_SAY_CACHE_DIR="${XDG_CACHE_HOME:-${HOME}/.cache}/piper-say"
cacheFile="${PIPER_SAY_CACHE_DIR}/state.txt"

cleanup_old_cache() {
  if [[ -d "${PIPER_SAY_CACHE_DIR}" ]]; then
    find "${PIPER_SAY_CACHE_DIR}" -type f -mtime +7 -delete 2>/dev/null || true
  fi
}

list_voices() {
  fd '\.onnx$' ~/.local/share/piper |
    sed "s|${PIPER_VOICES_DIR}/||" |
    sed 's|\.onnx$||'
}

[[ "${list}" == true ]] && {
  list_voices
  exit 0
}

if [[ -z "${voice}" ]]; then
  mapfile -t voices < <(list_voices)
  voice="$(gum choose --limit=1 --select-if-one "${voices[@]}")"
fi

model="${PIPER_VOICES_DIR}/${voice}.onnx"

if [[ ! -f "${model}" ]]; then
  log-warning "Voice not found: ${voice}"
  printYellow "Available voices:" >&2
  printYellow "$(list_voices)" >&2
  exit 0
fi

if command -v aplay &>/dev/null; then
  playerCmd=(aplay --quiet)
elif command -v mpv &>/dev/null; then
  playerCmd=(mpv --no-terminal)
fi

cleanup_old_cache

# --- Helper: prepare text for TTS --- #
tmp="$(mktemp)"
trap 'rm $tmp' EXIT
prepare_for_tts() {
  local input="$1"

  # 1. Detect if input is URL or file
  if [[ "${input}" =~ ^https?:// ]] || [[ "${input}" =~ ^https?:// ]]; then
    pandoc "${input}" -t plain --wrap=none -o "${tmp}"
  else
    # raw text from argument
    echo "${input}" >"${tmp}"
  fi

  # 2. Remove code blocks and markdown symbols
  # shellcheck disable=SC2016
  sed -i '/^    /d;/^```/,/^```/d' "${tmp}" # remove indented/fenced code blocks
  sed -i 's/[*_~`#>\[\]\(\)]+//g' "${tmp}"  # remove markdown symbols
  # sed -i 's/\s\{2,\}/ /g' "${tmp}"          # normalize whitespace

  # 3. Sentence chunking: one sentence per line
  awk '{
    while(match($0, /[.!?]+/)) {
      print substr($0, 1, RSTART+RLENGTH-1)
      $0 = substr($0, RSTART+RLENGTH)
    }
    if(length($0)>0) print $0
  }' "${tmp}" | sed '/^\s*$/d'
}

# --- Get input text --- #
# printf -v text '%b\n' "${argv[@]}"
str="$(input "${argv[@]}")"
text="$(prepare_for_tts "${str}")"
[[ -z "$(trim "${text}")" ]] && text="$(gum write)"

# --- Prepare Piper command --- #
piper_cmd=(piper-tts --quiet --model "${model}")

hashedText="$(printf '%s:%s' "${model}" "${text}" | b2sum)"
hashedText="${hashedText%% *}"

generateCache() {
  mkdir -p "${PIPER_SAY_CACHE_DIR}" &>/dev/null
  cat >"${cacheFile}" <<EOF
${hashedText}
${PIPER_SAY_CACHE_DIR}/output.wav
EOF
}

checkCache() {
  if [[ ! -s "${cacheFile}" || ! -f "${cacheFile}" || $(wc -l < "${cacheFile}") -ne 2 ]]; then
    return 1
  fi

  declare -A cachedState
  if ! cachedState[text]="$(viewlines 1 "${cacheFile}" 2>/dev/null)" || [[ -z "${cachedState[text]}" ]]; then
    return 1
  fi

  if ! cachedState[audio_file]="$(viewlines 2 "${cacheFile}" 2>/dev/null)" || [[ -z "${cachedState[audio_file]}" ]]; then
    return 1
  fi

  # Check if text is identical
  # Check if cached audio file exists and readable
  if [[ "${hashedText}" == "${cachedState[text]}" && -f "${cachedState[audio_file]}" && -r "${cachedState[audio_file]}" ]]; then
    # Cache hit
    if [[ -n "${out_file}" ]]; then
      # Check if destination exists and compare hashes
      if [[ -f "${out_file}" ]]; then
        local cached_hash
        local dest_hash
        cached_hash=$(b2sum "${cachedState[audio_file]}" 2>/dev/null | awk '{print $1}')
        dest_hash=$(b2sum "${out_file}" 2>/dev/null | awk '{print $1}')

        if [[ "${cached_hash}" == "${dest_hash}" ]] && [[ -n "${cached_hash}" ]]; then
          # Same content - no action needed
          terminate "Audio file copied from cache!"
        fi

        # Different content - ask to overwrite
        if gum confirm "[WARNING] File '${out_file}' exists, do you want to overwrite?"; then
          cp "${cachedState[audio_file]}" "${out_file}" >/dev/null &&
            terminate "Audio file copied from cache!"
        fi
        terminate
      else
        # Destination doesn't exist - copy from cache
        cp "${cachedState[audio_file]}" "${out_file}" &>/dev/null &&
          terminate "Audio file copied from cache!"
      fi
    else
      # Play from cache
      log-info "Audio playing from cache!"
      "${playerCmd[@]}" "${cachedState[audio_file]}" && exit 0
    fi
  fi

  return 1
}

if ! checkCache; then
  generateCache
fi

if [[ -f "${out_file}" ]]; then
  gum confirm "[WARNING] File '${out_file}' exists, do you want to overwrite?" || terminate
fi

spinner.sh "Generating..." &
SPINNER_PID=$!
trap 'killwait $SPINNER_PID' EXIT

if [[ -n "${out_file}" ]]; then

  piper_cmd+=(--output_file "${out_file}")

  "${piper_cmd[@]}" <<<"${text}" >/dev/null
  killwait "${SPINNER_PID}"

  log-success "Audio generated successfully at ${out_file}"
  gum confirm "Do you want to play the ouput?" && "${playerCmd[@]}" "${out_file}"
else
  out_file="${PIPER_SAY_CACHE_DIR}/output.wav"

  "${piper_cmd[@]}" --output_file "${out_file}" <<<"${text}" >/dev/null
  killwait "${SPINNER_PID}"

  log-success "Audio generated successfully!"
  "${playerCmd[@]}" "${out_file}"
fi

generateCache
