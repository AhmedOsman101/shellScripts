#!/usr/bin/env bash
#
# --- SCRIPT SIGNATURE --- #
#
#               ██
#               ▀▀
#  ██▄███▄    ████     ██▄███▄    ▄████▄    ██▄████            ▄▄█████▄   ▄█████▄  ▀██  ███
#  ██▀  ▀██     ██     ██▀  ▀██  ██▄▄▄▄██   ██▀                ██▄▄▄▄ ▀   ▀ ▄▄▄██   ██▄ ██
#  ██    ██     ██     ██    ██  ██▀▀▀▀▀▀   ██        █████     ▀▀▀▀██▄  ▄██▀▀▀██    ████▀
#  ███▄▄██▀  ▄▄▄██▄▄▄  ███▄▄██▀  ▀██▄▄▄▄█   ██                 █▄▄▄▄▄██  ██▄▄▄███     ███
#  ██ ▀▀▀    ▀▀▀▀▀▀▀▀  ██ ▀▀▀      ▀▀▀▀▀    ▀▀                  ▀▀▀▀▀▀    ▀▀▀▀ ▀▀     ██
#  ██                  ██                                                           ███
#
# --- DESCRIPTION --- #
# Text-to-speech script using Piper TTS and mpv
# Supports Pandoc input, Markdown, Word, PDF, HTML, URLs, and raw text
# Can pipe audio live or save to WAV
# --- DEPENDENCIES --- #
# - piper-tts | piper-tts (piper-tts-git)
# - mpv | aplay
# --- END SIGNATURE --- #

set -eo pipefail
trap 'exit 1' SIGUSR1

eval "$(include "lib/cmdarg.sh")"
eval "$(include "lib/helpers.sh")"
eval "$(include "check-deps")"
checkDeps "$0"

# --- cmdarg setup --- #
cmdarg_info "header" "$(get-desc "$0")"
cmdarg "l" "list" "Lists available voices"
cmdarg "v?" "voice" "The voice to use" ""
cmdarg "o?" "output" "Optional output WAV file path" ""
cmdarg "y" "yes" "Answer all questions with yes"
cmdarg_parse "$@"
# ---  Main script logic --- #
list="${cmdarg_cfg['list']}"
voice="${cmdarg_cfg['voice']}"
acceptAll="${cmdarg_cfg['yes']}"
out_file="${cmdarg_cfg['output']}"

PIPER_VOICES_DIR="${XDG_DATA_HOME:-${HOME}/.local/share}/piper"
PIPER_SAY_CACHE_DIR="${XDG_CACHE_HOME:-${HOME}/.cache}/piper-say"
cacheFile="${PIPER_SAY_CACHE_DIR}/state.txt"

cleanup_old_cache() {
  if [[ -d "${PIPER_SAY_CACHE_DIR}" ]]; then
    find "${PIPER_SAY_CACHE_DIR}" -type f -mtime +7 -delete 2>/dev/null || true
  fi
}

list_voices() {
  fd '\.onnx$' ~/.local/share/piper |
    sed "s|${PIPER_VOICES_DIR}/||" |
    sed 's|\.onnx$||'
}

select_player() {
  if command -v aplay &>/dev/null; then
    playerCmd=(aplay --quiet)
  elif command -v mpv &>/dev/null; then
    playerCmd=(mpv --no-terminal)
  fi
}

generateCache() {
  mkdir -p "${PIPER_SAY_CACHE_DIR}" &>/dev/null
  cat >"${cacheFile}" <<EOF
${hashedText}
${PIPER_SAY_CACHE_DIR}/output.wav
EOF
}

checkCache() {
  if [[ ! -s "${cacheFile}" || ! -f "${cacheFile}" || $(wc -l <"${cacheFile}") -ne 2 ]]; then
    return 1
  fi

  declare -A cachedState
  if ! cachedState[text]="$(viewlines 1 "${cacheFile}" 2>/dev/null)" || [[ -z "${cachedState[text]}" ]]; then
    return 1
  fi

  if ! cachedState[audio_file]="$(viewlines 2 "${cacheFile}" 2>/dev/null)" || [[ -z "${cachedState[audio_file]}" ]]; then
    return 1
  fi

  # Check if text is identical
  # Check if cached audio file exists and readable
  if [[ "${hashedText}" == "${cachedState[text]}" && -f "${cachedState[audio_file]}" && -r "${cachedState[audio_file]}" ]]; then
    # Cache hit
    if [[ -n "${out_file}" ]]; then
      # Check if destination exists and compare hashes
      if [[ -f "${out_file}" ]]; then
        local cached_hash
        local dest_hash
        cached_hash=$(b2sum "${cachedState[audio_file]}" 2>/dev/null | awk '{print $1}')
        dest_hash=$(b2sum "${out_file}" 2>/dev/null | awk '{print $1}')

        if [[ "${cached_hash}" == "${dest_hash}" ]] && [[ -n "${cached_hash}" ]]; then
          # Same content - no action needed
          terminate "Audio file copied from cache!"
        fi

        # Different content - ask to overwrite
        if [[ "${acceptAll}" == "true" ]] || gum confirm "[WARNING] File '${out_file}' exists, do you want to overwrite?"; then
          cp "${cachedState[audio_file]}" "${out_file}" >/dev/null &&
            terminate "Audio file copied from cache!"
        fi
        terminate
      else
        # Destination doesn't exist - copy from cache
        cp "${cachedState[audio_file]}" "${out_file}" &>/dev/null &&
          terminate "Audio file copied from cache!"
      fi
    else
      # Play from cache
      log-info "Audio playing from cache!"
      "${playerCmd[@]}" "${cachedState[audio_file]}" || terminate
      exit 0
    fi
  fi

  return 1
}

generateAudio() {
  local output_path="$1"

  # --- Prepare Piper command --- #
  piper_cmd=(piper-tts --quiet --model "${model}")

  if [[ -n "${output_path}" ]]; then
    piper_cmd+=(--output_file "${output_path}")
  fi

  "${piper_cmd[@]}" <<<"${text}" >/dev/null
}

[[ "${list}" == true ]] && {
  list_voices
  exit 0
}

if [[ -z "${voice}" ]]; then
  mapfile -t voices < <(list_voices)
  voice="$(gum choose --limit=1 --select-if-one "${voices[@]}")"
fi

model="${PIPER_VOICES_DIR}/${voice}.onnx"

if [[ ! -f "${model}" ]]; then
  log-warning "Voice not found: ${voice}"
  printYellow "Available voices:" >&2
  printYellow "$(list_voices)" >&2
  exit 0
fi

select_player
cleanup_old_cache

# --- Get input text --- #
if ((argc)); then
  text="$(prepare-tts-text "${argv[@]}")"
else
  text="$(gum write --placeholder='Enter some text...' | prepare-tts-text)"
fi

[[ -z "$(trim "${text}")" ]] && terminate "Nothing to do!"

hashedText="$(printf '%s:%s' "${model}" "${text}" | b2sum)"
hashedText="${hashedText%% *}"

if ! checkCache; then
  generateCache
fi

if [[ -f "${out_file}" ]]; then
  [[ "${acceptAll}" == "true" ]] || {
    gum confirm "[WARNING] File '${out_file}' exists, do you want to overwrite?" || terminate
  }
fi

spinner.sh "Generating..." &
SPINNER_PID=$!
trap 'killwait $SPINNER_PID' EXIT

if [[ -n "${out_file}" ]]; then
  generateAudio "${out_file}"
  killwait "${SPINNER_PID}"

  log-success "Audio generated successfully at ${out_file}"
  [[ "${acceptAll}" == "true" ]] || {
    gum confirm "Do you want to play output?" && "${playerCmd[@]}" "${out_file}"
  }
else
  out_file="${PIPER_SAY_CACHE_DIR}/output.wav"

  generateAudio "${out_file}"
  killwait "${SPINNER_PID}"

  log-success "Audio generated successfully!"
  "${playerCmd[@]}" "${out_file}"
fi

generateCache

exit 0
