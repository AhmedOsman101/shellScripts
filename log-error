#!/usr/bin/env bash
#
# --- SCRIPT SIGNATURE --- #
#
#  ▄▄▄▄
#  ▀▀██
#    ██       ▄████▄    ▄███▄██             ▄████▄    ██▄████   ██▄████   ▄████▄    ██▄████
#    ██      ██▀  ▀██  ██▀  ▀██            ██▄▄▄▄██   ██▀       ██▀      ██▀  ▀██   ██▀
#    ██      ██    ██  ██    ██   █████    ██▀▀▀▀▀▀   ██        ██       ██    ██   ██
#    ██▄▄▄   ▀██▄▄██▀  ▀██▄▄███            ▀██▄▄▄▄█   ██        ██       ▀██▄▄██▀   ██
#     ▀▀▀▀     ▀▀▀▀     ▄▀▀▀ ██              ▀▀▀▀▀    ▀▀        ▀▀         ▀▀▀▀     ▀▀
#                       ▀████▀▀
#
# --- DESCRIPTION --- #
# Prints error messages in red with a '[ERROR] ' prefix to stderr, signals parent with SIGUSR1, and exits with failure
# --- DEPENDENCIES --- #
#
# --- END SIGNATURE --- #

set -eo pipefail
trap 'exit 1' SIGUSR1

eval "$(include "lib/helpers.sh")"
eval "$(include "check-deps")"

checkDeps "$0"
# ---  Main script logic --- #
isNoKill=false
isNoError=false

while ((0 < $#)); do
  case "$1" in
  --no-kill)
    isNoKill=true
    shift
    ;;
  --no-error)
    isNoError=true
    shift
    ;;
  --safe)
    isNoKill=true
    isNoError=true
    shift
    ;;
  *) break ;; # Stop processing flags if an unknown argument is met
  esac
done

log.sh "ERROR" "$(input "$@")"

# If not interactive and isNoKill set to false
if ! { isInteractiveShell || "${isNoKill}"; }; then
  # Get parent PID (script that called log-error) and send SIGUSR1
  kill -SIGUSR1 "${PPID}" &>/dev/null || true
  wait "${PPID}" &>/dev/null || true
fi

"${isNoError}" && exit 0

# Exit with failure code (fallback if signal is ignored)
exit 1
