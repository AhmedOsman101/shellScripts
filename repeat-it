#!/usr/bin/env bash

# --- SCRIPT SIGNATURE --- #
#
#                                                                           â–ˆâ–ˆ
#                                                      â–ˆâ–ˆ                   â–€â–€       â–ˆâ–ˆ
#   â–ˆâ–ˆâ–„â–ˆâ–ˆâ–ˆâ–ˆ   â–„â–ˆâ–ˆâ–ˆâ–ˆâ–„   â–ˆâ–ˆâ–„â–ˆâ–ˆâ–ˆâ–„    â–„â–ˆâ–ˆâ–ˆâ–ˆâ–„    â–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–„  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ              â–ˆâ–ˆâ–ˆâ–ˆ     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
#   â–ˆâ–ˆâ–€      â–ˆâ–ˆâ–„â–„â–„â–„â–ˆâ–ˆ  â–ˆâ–ˆâ–€  â–€â–ˆâ–ˆ  â–ˆâ–ˆâ–„â–„â–„â–„â–ˆâ–ˆ   â–€ â–„â–„â–„â–ˆâ–ˆ    â–ˆâ–ˆ                   â–ˆâ–ˆ       â–ˆâ–ˆ
#   â–ˆâ–ˆ       â–ˆâ–ˆâ–€â–€â–€â–€â–€â–€  â–ˆâ–ˆ    â–ˆâ–ˆ  â–ˆâ–ˆâ–€â–€â–€â–€â–€â–€  â–„â–ˆâ–ˆâ–€â–€â–€â–ˆâ–ˆ    â–ˆâ–ˆ       â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ       â–ˆâ–ˆ       â–ˆâ–ˆ
#   â–ˆâ–ˆ       â–€â–ˆâ–ˆâ–„â–„â–„â–„â–ˆ  â–ˆâ–ˆâ–ˆâ–„â–„â–ˆâ–ˆâ–€  â–€â–ˆâ–ˆâ–„â–„â–„â–„â–ˆ  â–ˆâ–ˆâ–„â–„â–„â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–„â–„â–„             â–„â–„â–„â–ˆâ–ˆâ–„â–„â–„    â–ˆâ–ˆâ–„â–„â–„
#   â–€â–€         â–€â–€â–€â–€â–€   â–ˆâ–ˆ â–€â–€â–€      â–€â–€â–€â–€â–€    â–€â–€â–€â–€ â–€â–€     â–€â–€â–€â–€             â–€â–€â–€â–€â–€â–€â–€â–€     â–€â–€â–€â–€
#                      â–ˆâ–ˆ
#
# --- DESCRIPTION --- #
# Repeat a command until it succeeds
# --- DEPENDENCIES --- #
# - gum
# --- END SIGNATURE --- #

set -eo pipefail

trap 'exit 1' SIGUSR1

eval "$(include "lib/cmdarg.sh")"

eval "$(include "lib/helpers.sh")"

eval "$(include "check-deps")"
checkDeps "$0"
# ---  Main script logic --- #
cmdarg_info "header" "$(get-desc $0)"

cmdarg "p" "preserve" "Preserve output between retries (don't clear the screen)"
cmdarg "d?" "delay" "Delay in seconds between retries" "5"

cmdarg_parse "$@"

preserve=${cmdarg_cfg['preserve']}
delay=${cmdarg_cfg['delay']}
cmd=${cmdarg_argv[*]}

counter=1

if [[ -z ${cmd} ]]; then
  cmd=$(gum write --placeholder "enter a command to repeat...")
  # Evaluate the command to parse variables
  cmd=$(eval echo "${cmd}")
fi

# Check if the command is empty
[[ -z "${cmd}" ]] && log-error "No command entered."

# Infinite loop: repeat until success or interruption
while true; do
  if eval "${cmd}"; then
    if [[ ${counter} -ne 1 ]]; then
      echo ""
      log-success "Done after ${counter} retries ðŸš€!"
    fi
    break
  fi

  # Run gum spin, and check its exit status
  if ! gum spin \
    --title "Retrying '${cmd}' in ${delay}s..." \
    --title.foreground="${U_GREEN}" \
    --spinner.foreground="${U_GREEN}" \
    -- sleep ${delay}; then
    # If gum spin fails (e.g., due to Ctrl+C), exit
    if [[ ${counter} -ne 1 ]]; then
      echo ""
      terminate "Program terminated after ${counter} retries"
    else
      echo ""
      terminate
    fi
  fi

  [[ "${preserve}" != true ]] && clear
  ((counter++))
done
